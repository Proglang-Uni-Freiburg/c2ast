\section{Iso-recursion}
\label{sec:iso-recursion}

The traditional equi-recursive system can---with very few and localized changes---be turned
into an iso-recursive system. The type syntax and dualization of
session types require no adjustments.

We extend the syntax with an extra expression to unroll a recursive
type:
\begin{align*}
    e \grmdef&
               \EUnroll e
\end{align*}

Extra process reduction rules
\begin{mathpar}
    % \reducerule{
    %   \PScope (\PPar* {\ERoll a} {\ERoll b})
    % }{
    %   \PPar* a b
    % }
    %   
    \reducerule{
      \PScope (\PPar* {\EUnroll a} {\EUnroll b})
    }{
      \PPar* a b
    }
\end{mathpar}

We replace the typing rule for conversion by a rule for explicit
unrolling.
\begin{mathpar}
    \inferrule{
      \typing{e}{\TRec S}
    }{
      \typing{\EUnroll e}{S[\TRec[X] S / X]}
    }
\end{mathpar}

The equi-recursive nature of this adjusted system handles any necessary
(un)rolling of recursive session types. This behavior is captured in the type
equivalence relation defined in Figure~\ref{fig:equi-equivalence}. Equivalence
$f : T \eqt T' : f'$ gives rise to two functions $f : \TFun {T} {T'}$, $f' :
\TFun {T'} {T}$. Equivalence of session types $g : S \eqs S' : g'$ gives rise
to two functions $g : \TFun {\TPair {S} {\TDual{S'}}} \TUnit$ and $g' :
\TFun {\TPair {S'} {\TDual{S}}} \TUnit$. All of these functions are
expressions in the iso-recursive system.

At the same time, the equi-recursive nature obviates the need for $\EkwRoll$
and $\EkwUnroll$ operations. These two values, their two typing rules and
reductions are removed. Instead, a rule is added which uses the equi-recursive
type equivalence.

\subsection{Types}


\declrel{Dualization of session types}[$\TDual S = S$]
\begin{align*}
  \TDual X &= X                               &
  \TDual{\TEnd !} &= \TEnd ?                  &
  \TDual{\TOut T S} &= \TIn T \TDual{S}       &
  \TDual{\TSelect{ l_i: S_i }} &=
    \TCase{ l_i: \TDual{S_i} }                \\
  \TDual{\TRec S} &= \TRec{\TDual S}          &
  \TDual{\TEnd ?} &= \TEnd !                  &
  \TDual{\TIn T S} &= \TOut T \TDual{S}       &
  \TDual{\TCase{ l_i: S_i }} &=
    \TSelect{ l_i: \TDual{S_i} }
\end{align*}

% The type syntax for the iso-recursive system is the same as in the
% equi-recursive system, including the notion of session type dualization.
% 
% Type equivalence for the iso-recursive system is largely the same as in the
% equi-recursive system except for the rules \textsc{\EqUnrollL} and
% \textsc{\EqUnrollR}, which do not exist.

\vv{
  \begin{itemize}
  \item The dual function for recursive types is a bit more complicated; pls have
    a look at ``the final cut''.
    \pt{restricted payload type to closed types}
  \item Iso-recursive expressions $e$ must appear before type equivalence.
    \js{fixed this by moving sections around}
  \item IMO, $T,U$ reads better than $T_1, T_2$.
    \pt{sorry, messed this up!}
    \js{changed it}
  \item The expression for session types isomorphism may be curried. Then we
    seek these results, right? (do they hold?)

    \pt{Yes, see below in Sec~\ref{sec:properties}}

    Lemma. If $e : T \eqt U$, then $\typing{e}{\TFun{T}{U}}$.

    Lemma. If $e : R \eqs S$, then $\typing{e}{\TFun{R}{\TFun{\TDual S}{\TUnit}}}$.
  \item $f^{-1}$ is confusing; why not a simple $g$?
    \pt{Fixed, differently}
\item Added an easier to read, IMO, rule for \EqFun{} and (curried)
  for \EqOut
  \pt{Messed this up. Sorry again}
\item \EqPair{} uses an abbreviation, right? $\lambda p. \text{let}(x,y) = p
  \text{ in } \dots$
  \js{added note about this abbreviation next to grammar}
\item Added suggestion for roll and unroll; these constants may have function
  types. (types don't work :(
  \end{itemize}
}


\subsection{Expressions}

% The term syntax of the iso-recursive system is the same as for the
% equi-recursive system with two additional values.
% \begin{align*}
%   v \grmdef& \dots \grmor \EkwRoll \grmor \EkwUnroll
% \end{align*}


\subsubsection{Expression typing}

\declrel{Typing contexts}
\begin{align*}
  \Ctxt \grmdef&
    \CNil \grmor \Ctxt, \CBind x T \grmor \Ctxt, \CBind* x T
\end{align*}

\declrel{Context exhaustion}[$\CExhausted$]
\begin{mathpar}
  \inferrule{ }{\CExhausted[\CNil]} \and
  \inferrule{\CExhausted}{\CExhausted[\Ctxt, \CBind* x T]}
\end{mathpar}

\declrel{Context splitting}[$\Ctxt = \CSplit[\Ctxt][\Ctxt]$]
\begin{mathpar}
  \inferrule{}{\cdot = \CSplit[\cdot][\cdot]} \and
  \inferrule{\Ctxt = \CSplit}{\Ctxt, \CBind  x T = \CSplit[(\Ctxt_1 , \CBind  x T)][ \Ctxt_2               ]} \and
  \inferrule{\Ctxt = \CSplit}{\Ctxt, \CBind  x T = \CSplit[ \Ctxt_ 1              ][(\Ctxt_2 , \CBind  x T)]} \and
  \inferrule{\Ctxt = \CSplit}{\Ctxt, \CBind* x T = \CSplit[(\Ctxt_1 , \CBind* x T)][(\Ctxt_2 , \CBind* x T)]}
\end{mathpar}

\input{fig-typing}

% Typing of expressions in the iso-recursive system is largely the same as for
% expressions in the equi-recursive system. As the only change, two additional
% typing rules are introduced concerned with $\EkwRoll$ and $\EkwUnroll$.
% \begin{mathpar}
%   \inferrule{
%     \typing{e}{S[\TRec[X] S / X]}
%   }{
%     \typing{\ERoll e}{\TRec S}
%   }
% 
%   \inferrule{
%     \typing{e}{\TRec S}
%   }{
%     \typing{\EUnroll e}{S[\TRec[X] S / X]}
%   }
% \end{mathpar}

% Evaluation contexts for the iso-recursive system have the same shape as the
% contexts in the equi-recursive system. The reduction relation is extended by
% two rules concerned with $\EkwRoll$ and $\EkwUnroll$.
% \begin{mathpar}
%   \reducerule{
%     \PScope (\PPar {E[\ERoll a]} {p})
%   }{
%     \PScope (\PPar {E[a]} {p})
%   }
% 
%   \reducerule{
%     \PScope (\PPar {E[\EUnroll a]} {p})
%   }{
%     \PScope (\PPar {E[a]} {p})
%   }
% \end{mathpar}
% Dual $\PScope[b,a]$ rules omitted.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
