
\section{Properties}
\label{sec:properties}

% The type syntax for the iso-recursive system is the same as in the
% equi-recursive system, including the notion of session type dualization.
% 
% Type equivalence for the iso-recursive system is largely the same as in the
% equi-recursive system except for the rules \textsc{\EqUnrollL} and
% \textsc{\EqUnrollR}, which do not exist.

\vv{
  \begin{itemize}
  \item The dual function for recursive types is a bit more complicated; pls have
    a look at ``the final cut''.
    \pt{restricted payload type to closed types}
  \item Iso-recursive expressions $e$ must appear before type equivalence.
    \js{fixed this by moving sections around}
  \item IMO, $T,U$ reads better than $T_1, T_2$.
    \pt{sorry, messed this up!}
    \js{changed it}
  \item The expression for session types isomorphism may be curried. Then we
    seek these results, right? (do they hold?)

    \pt{Yes, see below in Sec~\ref{sec:properties}}

    Lemma. If $e : T \eqt U$, then $\typing{e}{\TFun{T}{U}}$.

    Lemma. If $e : R \eqs S$, then $\typing{e}{\TFun{R}{\TFun{\TDual S}{\TUnit}}}$.
  \item $f^{-1}$ is confusing; why not a simple $g$?
    \pt{Fixed, differently}
\item Added an easier to read, IMO, rule for \EqFun{} and (curried)
  for \EqOut
  \pt{Messed this up. Sorry again}
\item \EqPair{} uses an abbreviation, right? $\lambda p. \text{let}(x,y) = p
  \text{ in } \dots$
  \js{added note about this abbreviation next to grammar}
\item Added suggestion for roll and unroll; these constants may have function
  types. (types don't work :(
  \end{itemize}
}



TODO (PJT): what do we mean with $\cong$?
\begin{itemize}
\item for ``normal'' types, it should be contextual equivalence(?)
\item for channels, it might be bisimilarity(?)
\item might be simpler with an LTS semantics, see proposed definition:
\end{itemize}

\begin{definition}
  For $\typing[\CNil]{e_1, e_2} T$ define contextual equivalence $e_1 \cong e_2$
  iff, for all contexts $C : T \to \TUnit$, $C[e_1] \Downarrow$ iff $C[e_2] \Downarrow$. 
\end{definition}

\begin{lemma}[Conversions]~\\[-\baselineskip]
  \begin{enumerate}
    \item If $f : T \eqt T'$, then $f' : T' \eqt T$
      such that $\typing[\CNil]{f}{\TFun T{T'}}$
      and  $\typing[\CNil]{f'}{\TFun {T'}T}$
      and  $f \circ f' \cong \ELam x x$
      and  $f' \circ f \cong \ELam x x$.
    \item If $g : S \eqs S'$, then $g' : S' \eqs S$
      such that $\typing[\CNil]{g}{\TFun {\TPair {S} {\TDual{S'}}} \TUnit}$
      and $\typing[\CNil]{g'}{\TFun {\TPair {S'} {\TDual{S}}} \TUnit}$
      and,\\
      for all channels $c : S$,  $c \cong \ELet{c'}{\EFork{( \ELam {\bar c'} g \; (c, \bar c')) }}{\EFork{( \ELam {\bar c} g' \; (c', \bar c)) }} $.
\end{enumerate}
\end{lemma}

Proving contextual equivalence is daunting. Maybe set up a logical relation? But how to do the session part?
(I don't think it works like this!)

\begin{definition}
  Define $\reduceto e{e'}$ by $\reducemany e{e'}$ and $e'$
  irreducible.
\end{definition}
\begin{align*}
  V (\TUnit) & = \{ (\EUnit, \EUnit) \}
  \\
  V (\TPair TU) & = \{ (v_1, v_2), (w_1, w_2) \mid (v_1, w_1) \in V (T), (v_2, w_2) \in V (U) \}
  \\
  V (\TFun TU) &= \{ (\ELam xe_1, \ELam xe_2) \mid \forall v, w. (v, w) \in V (T) \Rightarrow (e_1[v/x], e_2[w/x]) \in E (U)  \}
  \\
  V (\TEnd!) &= \{ (c_1, c_2) \mid
                       \reduce{\ETerm c_1}{\EUnit}, \reduce{\ETerm
                       c_2}{\EUnit} \}
  \\
  V (\TEnd?) &= \{ (c_1, c_2) \mid
               \reduce{\EWait c_1}{\EUnit}, \reduce{\EWait
                       c_2}{\EUnit} \}
  \\
  V (\TIn TS) &= \{ (c_1, c_2) \mid
                \reduce{\ERecv c_1}{(v, c_1')}, 
                \reduce{\ERecv c_2}{(w, c_2')},
                (v,w) \in V(T),
                (c_1', c_2') \in V (S) \}
  % \\
  %               &\stackrel{?}{=}
  %                 \{ (c_1, c_2) \mid 
  %                 (\ERecv c_1,  \ERecv c_2) \in E (\TPair TS) \}
  \\
  V (\TOut TS) &= \{ (c_1, c_2) \mid \forall v, w. (v,w) \in V(T)
                \Rightarrow
                \reduce{\ESend v c_1}{c_1'}, 
                 \reduce{\ESend w c_2}{c_2'},
                 (c_1', c_2') \in V(S) \}
  % \\
  %               &\stackrel{?}{=}
  %                 \{ (c_1, c_2) \mid \mid \forall v, w. (v,w) \in V(T)
  %               \Rightarrow
  %                 (\ESend v c_1,  \ESend w c_2) \in E (S) \}
  \\
  V (\TSelect{l_i: S_i}) &=  \{ (c_1, c_2) \mid \forall j. j \in I
                           \Rightarrow
                           \reduce{\ESelect{l_j} c_1 }{c_1'}, 
                           \reduce{\ESelect{l_j} c_2 }{c_2'},
                           (c_1', c_2') \in V(S_j)
                           \}
  % \\&\stackrel{?}{=}
  % \{ (c_1, c_2) \mid \forall j. j \in I
  % \Rightarrow
  % (\ESelect{l_j}{c_1}, \ESelect{l_j}{c_1}) \in E (S_j)
  % \}
  \\
  V (\TCase{l_i: S_i})
             &= \{ (c_1, c_2) \mid \forall j. j \in I \Rightarrow
                         c_1 \stackrel{?l_j}{\to} e_1[c_1],
                c_2 \stackrel{?l_j}{\to} e_2[c_2],
                         (e_1, e_2) \in E(S_j) \}
  \\&\stackrel{?}{=}
  \{ (c_1, c_2) \mid
  \reduce{\ECase{c_1}{l_i \to e_{1i}}}{e_{1j}\; c_1'}, 
  \reduce{\ECase{c_2}{l_i \to e_{2i}}}{e_{2j}\; c_2'},
  (c_1', c_2') \in V (S_j)
  \}
  % \\&\stackrel{??}{=}
  % \{ (c_1, c_2) \mid \exists j\in I, (\ECase{c_1}{\dots},
  % \ECase{c_2}{\dots}) \in E (S_j) \}
  \\
  E (T) &= \{ (e_1, e_2) \mid \forall v_1, v_2, E_1, E_2. \reduceto{e_1}{E_1[v_1]}, \reduceto{e_2}{ E_2[v_2]} \Rightarrow (v_1, v_2)\in V (T) \}
\end{align*}

The session part seems wrong. I think we have to talk about processes stuck on a communication.
The following is inspired by a paper by Perez, Toninho, Pfenning ($+$ will need step indexing to deal with recursion): 

\begin{align*}
  L (c : \TEnd!) &= \{ (E[ \ETerm c ], E'[ \ETerm c ]) \mid (E[\EUnit], E'[\EUnit]) \in E (\TUnit)
                   \}
  \\
  L (c : \TOut TS) &= \{ (E[ \ESend v c ], E'[ \ESend w c ]) \mid \forall v, w. (v, w) \in V (T) \Rightarrow (E[c], E'[c]) \in L^* (c : S) \}
  \\
  L (c : \TIn TS) &= \{ (E[ \ERecv c ], E'[ \ERecv c ]) \mid \forall v, w. (v, w) \in V (T) \Rightarrow (E[(v,c)], E'[(w,c)]) \in L^* (c : S) \}
  \\
  L^* (c : S) &= \{ (e_1, e_2) \mid \forall e_1', e_2'. e_1 \to^* e_1', e_2 \to^* e_2' \Rightarrow (e_1', e_2') \in L (c : S) \}
\end{align*}

\subsection{Attempt at Vasco's suggestion}
\label{sec:attempt-at-vascos}

\begin{lemma}[Equational correspondence for expressions]
  Suppose $\Ctxt \vdash e_1 \leadsto e'_1 : T$ where $\Ctxt$ contains only
  channel bindings.
  \begin{enumerate}
  \item
    If $\reduce[\alpha]{e_1}{e_2}$
    and $\Ctxt \vdash e_2 \leadsto e'_2 : T$, then
    $\reducemany[\alpha]{e'_1}{e'_3}$ and $e_3' = e_2'$.
  % \item If $\reduce[\alpha]{e'_1}{e'_3}$, then $\reduce[\alpha]{e_1}{e_2}$ and
  %   $\reducemany[\alpha]{e'_3}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \end{enumerate}
\end{lemma}

Define $e_1 = e_2$: reflexive, transitive, congruence, symmetric
closure of all expression reductions, and fork. As well as process
reduction on restricted channels. 
\begin{mathpar}
  \reduce[a!v]{\ESend v a}{a}

  \dots

  \inferrule{
    \reduce[\alpha]{e}{e'}
  }{
    \reduce[\alpha]{E[e]}{E[e']}
  }
  \\
  \text{process reductions}
  \\
  \inferrule{
    \reduce[a!v]{p_1}{p_1'} \\
    \reduce[b?v]{p_2}{p_2'}
  }{
    \reduce[a!v, b?v]{\PPar{p_1}{p_1'} }{\PPar{p_2}{p_2'} }
  }

  \inferrule{
    \reduce[a!v, b?v]{p }{p' }
  }{
    \reduce[\tau]{\PScope p}{\PScope {p'}}
  }
\end{mathpar}

\newpage
\begin{lemma}[Operational correspondence for expressions]
  Suppose $\Ctxt \vdash e_1 \leadsto e'_1 : T$ where $\Ctxt$ contains only
  channel bindings. \begin{enumerate}
  \item If $\reduce[\alpha]{e_1}{e_2}$, then
    $\reducemany[\alpha]{e'_1}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \item If $\reduce[\alpha]{e'_1}{e'_3}$, then $\reduce[\alpha]{e_1}{e_2}$ and
    $\reducemany[\alpha]{e'_3}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \end{enumerate}
\end{lemma}
\begin{proof} Item 1.
  The proof is by rule induction on $\Ctxt \vdash e_1 \leadsto e'_1 : T$.
  %
  Case the top-level translation rule is
  \begin{mathpar}
    \inferrule{
      \Ctxt \vdash e \leadsto e' : T \\
      f : T \eqt U
    }{
      \Ctxt \vdash e \leadsto f e' : U
    }
  \end{mathpar}

  Then, we know (premises) that $\Ctxt \vdash e_1 \leadsto e'_1 : T$ and $f : T
  \eqt U$.
  %
  We need to show that $\reducemany[\alpha]{f e_1'}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  %
  At this point I suggest proceeding by rule induction on
  $\reduce[\alpha]{e_1}{e_2}$. Details to be seen.

  \pt{Agreed, this part works ok. But what follows troubles me.}

  However, if $e_1$ is a value, then so is $e_1'$ (lemma!). 

  Proceed by induction on $f : T \eqt U$?

  Or: prove that if I can observe some $\alpha$ on $e_1$, then I can
  observe the same $\alpha$ on $f e_1'$.

  \begin{itemize}
  \item $\alpha = \ELetU\EHole{e''}$
  \item $\alpha = \ELetP xy\EHole{e''}$
  \item $\alpha = \EHole\; v$
  \item $\alpha = \EWait\EHole$
  \item $\alpha = \ETerm\EHole$
  \item $\alpha = \ESend{v}\EHole$
  \item $\alpha = \ERecv\EHole$
  \item $\alpha = \ESelect l \EHole$
  \item $\alpha = \ECase\EHole{l_i: e_i}$
  \end{itemize}
  
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
