
\section{Properties}
\label{sec:properties}

% The type syntax for the iso-recursive system is the same as in the
% equi-recursive system, including the notion of session type dualization.
% 
% Type equivalence for the iso-recursive system is largely the same as in the
% equi-recursive system except for the rules \textsc{\EqUnrollL} and
% \textsc{\EqUnrollR}, which do not exist.

\vv{
  \begin{itemize}
  \item The dual function for recursive types is a bit more complicated; pls have
    a look at ``the final cut''.
    \pt{restricted payload type to closed types}
  \item Iso-recursive expressions $e$ must appear before type equivalence.
    \js{fixed this by moving sections around}
  \item IMO, $T,U$ reads better than $T_1, T_2$.
    \pt{sorry, messed this up!}
    \js{changed it}
  \item The expression for session types isomorphism may be curried. Then we
    seek these results, right? (do they hold?)

    \pt{Yes, see below in Sec~\ref{sec:properties}}

    Lemma. If $e : T \eqt U$, then $\typing{e}{\TFun{T}{U}}$.

    Lemma. If $e : R \eqs S$, then $\typing{e}{\TFun{R}{\TFun{\TDual S}{\TUnit}}}$.
  \item $f^{-1}$ is confusing; why not a simple $g$?
    \pt{Fixed, differently}
\item Added an easier to read, IMO, rule for \EqFun{} and (curried)
  for \EqOut
  \pt{Messed this up. Sorry again}
\item \EqPair{} uses an abbreviation, right? $\lambda p. \text{let}(x,y) = p
  \text{ in } \dots$
  \js{added note about this abbreviation next to grammar}
\item Added suggestion for roll and unroll; these constants may have function
  types. (types don't work :(
  \end{itemize}
}



TODO (PJT): what do we mean with $\cong$?
\begin{itemize}
\item for ``normal'' types, it should be contextual equivalence(?)
\item for channels, it might be bisimilarity(?)
\item might be simpler with an LTS semantics, see proposed definition:
\end{itemize}

\begin{definition}
  For $\typing{e_1, e_2} T$ define $e_1 = e_2$
  as the reflexive, transitive, symmetric, congruence closure of all
  silent reductions, the equalities of the computational lambda
  calculus, and extensionality.
\end{definition}

\begin{lemma}[Conversions]~\\[-\baselineskip]
  \begin{enumerate}
    \item If $f : T \eqt T'$, then $f' : T' \eqt T$
      such that $\typing[\CNil]{f}{\TFun T{T'}}$
      and  $\typing[\CNil]{f'}{\TFun {T'}T}$
      and  $f \circ f' = \ELam x x$
      and  $f' \circ f = \ELam x x$.
    \item If $g : S \eqs S'$, then $g' : S' \eqs S$
      such that $\typing[\CNil]{g}{\TFun {\TPair {S} {\TDual{S'}}} \TUnit}$
      and $\typing[\CNil]{g'}{\TFun {\TPair {S'} {\TDual{S}}} \TUnit}$
      and,\\
      for all channels $c : S$,  $c = \ELet{c'}{\EFork{( \ELam {\bar c'} g \; (c, \bar c')) }}{\EFork{( \ELam {\bar c} g' \; (c', \bar c)) }} $.
\end{enumerate}
\end{lemma}
\begin{proof}
  \begin{enumerate}
  \item Induction on $T$ (beta equality is not sufficient; need
    reductions from computational lambda calculus, which are sound for
    call-by-value with effects)
    \begin{itemize}
    \item Case $\TUnit$: $f = \ELam x x$, $f' = \ELam x x$, clearly
      \begin{align*}
        (\ELam x (\ELam x x) ((\ELam x x) x)) &= \ELam x x
      \end{align*}
    \item Case $\TPair TU$: $f = \ELam {(x_1,x_2)} (f_T \; x_1, f_U \;
      x_2)$, $f' = \ELam {(x_1,x_2)} (f'_T \; x_1, f'_U \; x_2)$
      \begin{align*}
        \ELam x f' (f\; x)
        &= \ELam x f' (\ELetP{x_1}{x_2} x (f_T \; x_1, f_U \; x_2)) \\
        &= \ELam x \ELetP{x_1}{x_2}{ (\ELetP{x_1}{x_2} x (f_T \; x_1,
          f_U \; x_2))}  (f'_T \; x_1, f'_U \; x_2)\\
        &= \ELam x
          \ELetP{x_1}{x_2} x \ELetP{x_1}{x_2}{ (f_T \; x_1,
          f_U \; x_2)}  (f'_T \; x_1, f'_U \; x_2)\\
        &= \ELam x
          \ELetP{x_1}{x_2} x  (f'_T \; (f_T\; x_1), f'_U \; (f_U\;
          x_2))\\
        & \text{IH for }f_T, f_T', f_U, f_U' \\
        &= \ELam x
          \ELetP{x_1}{x_2} x  (x_1,x_2)\\
        &= \ELam x x
      \end{align*}
    \item Case $\TFun TU$: $f = \ELam x f_U \circ x \circ f_{T'}$, $f'
      = \ELam x f'_U \circ x \circ f_T$
      \begin{align*}
        \ELam x f' (f\; x)
        &= \ELam x f' ((\ELam x f_U \circ x \circ f_{T'})\; x) \\
        &= \ELam x (\ELam x f'_U \circ x \circ f_T)\; ((\ELam x f_U \circ x \circ f_{T'})\; x) \\
        &= \ELam x (\ELam x f'_U \circ x \circ f_T)\; (f_U \circ x \circ f_{T'}) \\
        &= \ELam x (f'_U \circ (f_U \circ x \circ f_{T'})
          \circ f_T) \\
        & \text{need to invoke extensionality to apply the IH in the
          form } f'_U \circ f_U = \ELam z z  \\
        &= \ELam x x
      \end{align*}
    \item Case $S$: $f = \ELam {c_1} \EFork{ \ELam {c_2} g \; (c_1,
        c_2) }$, 
      $f' = \ELam {c_1} \EFork{ \ELam {c_2} g' \; (c_1, c_2) }$
      \begin{align*}
        \ELam x f' (f\; x)
        &= \ELam x f' ((\ELam {c_1} \EFork{ \ELam {c_2} g \; (c_1,
          c_2) })\; x) \\
        &= \ELam x
          (\ELam {c_1} \EFork{ \ELam {c_2} g' \; (c_1, c_2)})
          ((\ELam {c_1} \EFork{ \ELam {c_2} g \; (c_1, c_2) })\; x) \\
        &= \ELam x
          (\ELam {c_1} \EFork{ \ELam {c_2} g' \; (c_1, c_2)})
          (\EFork{ \ELam {c_2} g \; (x, c_2) }) \\
        &= \ELam x
          \EFork{ \ELam {c_2} g' \; ((\EFork{ \ELam {c_2} g \; (x,
          c_2) }), c_2)} \\
        & \text{by part~2} \\
        & = \ELam x x
      \end{align*}
    \end{itemize}
  \item Just considering cases on $S$ is technically fishy, but \dots
    \begin{itemize}
    \item Case $x : \TEnd!$:
      $g = \ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}$,
      $g' = \ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}$
      \begin{align*}
        & 
        \EFork{ \ELam {c_2} g' \; ((\EFork{ \ELam {c_2} g \; (x,
        c_2) }), c_2)} \\
        &=
        \EFork{ \ELam {c_2} g' \; ((\EFork{ \ELam {c_2} (\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; (x,
        c_2) }), c_2)} \\
        &=
        \EFork{ \ELam {c_2} (\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; ((\EFork{ \ELam {c_2} (\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; (x,
        c_2) }), c_2)} \\
        &=
          \PScope
          (\PPar a {(\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; ((\EFork{ \ELam {c_2} (\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; (x,
        c_2) }), b)}) \\
        &=
          \PScope
          (\PPar a {(\ELetU {\EWait {b}} {\ETerm {(\EFork{ \ELam {c_2} (\ELam {(c_1, c_2)} \ELetU {\EWait {c_2}} {\ETerm {c_1}}) \; (x,
        c_2) })}})}) \\
        &=
          \PScope
          (\PPar a {(\ELetU {\EWait {b}} {\ETerm {(\EFork{ \ELam {c_2} (\ELetU {\EWait {c_2}} {\ETerm {x}}) })}})}) \\
        &=
          \PScope
          (\PPar a {(\PScope[a',b'] \PPar {(\ELetU {\EWait {b}} {\ETerm
          {a'}}} {{ \ELetU {\EWait {b'}} {\ETerm {x}}) }})}) \\
        & \text{the typing dictates to consider }\ETerm a = \ETerm x \\
        & \PScope (\PPar {\ETerm a} {(\PScope[a',b'] \PPar {(\ELetU {\EWait {b}} {\ETerm
          {a'}}} {{ \ELetU {\EWait {b'}} {\ETerm {x}}) }})}) \\
        &=\PScope[a',b'] \PPar {({\ETerm
          {a'}}} {{ \ELetU {\EWait {b'}} {\ETerm {x}}) }} \\
        &=  \ETerm {x}
      \end{align*}
    \end{itemize}
  \end{enumerate}
\end{proof}



\subsection{Attempt at Vasco's suggestion}
\label{sec:attempt-at-vascos}

\begin{lemma}[Equational correspondence for expressions]
  Suppose $\Ctxt \vdash e_1 \leadsto e'_1 : T$ where $\Ctxt$ contains only
  channel bindings.
  \begin{enumerate}
  \item
    If $\reduce[\alpha]{e_1}{e_2}$
    and $\Ctxt \vdash e_2 \leadsto e'_2 : T$, then
    $\reducemany[\alpha]{e'_1}{e'_3}$ and $e_3' = e_2'$.
  % \item If $\reduce[\alpha]{e'_1}{e'_3}$, then $\reduce[\alpha]{e_1}{e_2}$ and
  %   $\reducemany[\alpha]{e'_3}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \end{enumerate}
\end{lemma}

Define $e_1 = e_2$: reflexive, transitive, congruence, symmetric
closure of all expression reductions, and fork. As well as process
reduction on restricted channels. 
\begin{mathpar}
  \reduce[a!v]{\ESend v a}{a}

  \dots

  \inferrule{
    \reduce[\alpha]{e}{e'}
  }{
    \reduce[\alpha]{E[e]}{E[e']}
  }
  \\
  \text{process reductions}
  \\
  \inferrule{
    \reduce[a!v]{p_1}{p_1'} \\
    \reduce[b?v]{p_2}{p_2'}
  }{
    \reduce[a!v, b?v]{\PPar{p_1}{p_1'} }{\PPar{p_2}{p_2'} }
  }

  \inferrule{
    \reduce[a!v, b?v]{p }{p' }
  }{
    \reduce[\tau]{\PScope p}{\PScope {p'}}
  }
\end{mathpar}

\newpage
\begin{lemma}[Operational correspondence for expressions]
  Suppose $\Ctxt \vdash e_1 \leadsto e'_1 : T$ where $\Ctxt$ contains only
  channel bindings. \begin{enumerate}
  \item If $\reduce[\alpha]{e_1}{e_2}$, then
    $\reducemany[\alpha]{e'_1}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \item If $\reduce[\alpha]{e'_1}{e'_3}$, then $\reduce[\alpha]{e_1}{e_2}$ and
    $\reducemany[\alpha]{e'_3}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  \end{enumerate}
\end{lemma}
\begin{proof} Item 1.
  The proof is by rule induction on $\Ctxt \vdash e_1 \leadsto e'_1 : T$.
  %
  Case the top-level translation rule is
  \begin{mathpar}
    \inferrule{
      \Ctxt \vdash e \leadsto e' : T \\
      f : T \eqt U
    }{
      \Ctxt \vdash e \leadsto f e' : U
    }
  \end{mathpar}

  Then, we know (premises) that $\Ctxt \vdash e_1 \leadsto e'_1 : T$ and $f : T
  \eqt U$.
  %
  We need to show that $\reducemany[\alpha]{f e_1'}{e'_2}$ and $\Ctxt \vdash e_2 \leadsto e'_2 : T$.
  %
  At this point I suggest proceeding by rule induction on
  $\reduce[\alpha]{e_1}{e_2}$. Details to be seen.

  \pt{Agreed, this part works ok. But what follows troubles me.}

  However, if $e_1$ is a value, then so is $e_1'$ (lemma!). 

  Proceed by induction on $f : T \eqt U$?

  Or: prove that if I can observe some $\alpha$ on $e_1$, then I can
  observe the same $\alpha$ on $f e_1'$.

  \begin{itemize}
  \item $\alpha = \ELetU\EHole{e''}$
  \item $\alpha = \ELetP xy\EHole{e''}$
  \item $\alpha = \EHole\; v$
  \item $\alpha = \EWait\EHole$
  \item $\alpha = \ETerm\EHole$
  \item $\alpha = \ESend{v}\EHole$
  \item $\alpha = \ERecv\EHole$
  \item $\alpha = \ESelect l \EHole$
  \item $\alpha = \ECase\EHole{l_i: e_i}$
  \end{itemize}
  
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
