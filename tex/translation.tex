\section{Translating equi-recursion to iso-recursion and back}

\subsection{Forward translation}
\label{sec:forward}


The set of syntactically valid expressions in the equi-recursive system is a
subset of the syntactically valid expressions in the iso-recursive system. A
simple one-to-one mapping, however, does not preserve well-typedness because
the target type system is explicit about unrolling of the recursive type.

\input{fig-translation}

Instead, the translation judgment $\translation e {e'} T$ in
Figure~\ref{fig:translation} describes the translation of an equi-recursively
typed expression $e$ to an equivalent expression $e'$ in the iso-recursive
system. The only interesting part of the translation process is where the
equi-recursive system makes use of type conversions. Here, an appriopriate
conversion function is inserted on the iso-recursive side. These
conversion expressions are specified by the blue parts in figure~\ref{fig:equi-equivalence}.
\begin{mathpar}
  \inferrule{
      \translation e {e'} T \\
      f : T \eqt U
    }{
      \translation e {f \; e'} U
    }
\end{mathpar}

To prove that the translation preserves well-typedness, we
need a few properties of the conversion expression $f$.
\begin{lemma}
  \begin{enumerate}
  \item If $f : T \eqt U$, then $\typing[\CNil]{\tyIso f}{\TFun TU}$.
  \item If $g : R \eqs S$, then $\typing[\CNil]{\tyIso g}{\TFun{\TPair
      R {\TDual S}} \TUnit}$.
  \end{enumerate}
\end{lemma}
Technically, the expression $g$ generated by the coinductively defined
judgment $g : R \eqs S$ can be infinitely big. However, the proof of
such a judgment is a regular tree so that $g$ can be finitely
represented by a recursive function. The details of turning regular
coinduction into induction are well-known
\cite{DBLP:conf/popl/HengleinN11,DBLP:journals/jfp/GapeyevLP02,DBLP:journals/lmcs/Dagnino21}
and hence omitted.

\begin{lemma}
  \begin{enumerate}
  \item $\typing{\tyEqui e} T$ iff there is some $e'$ such that
    $\translation e {e'} T$.
  \item If $\translation e {e'} T$, then $\typing{\tyIso e'} T$.
  \end{enumerate}
\end{lemma}

\subsection{Backward translation}
\label{sec:backward-translation}

The reverse translation $\IsoToEqui\cdot$ from iso-recursion to equi-recursion is even
simpler. The translation just removes each occurrence of $\EUnroll\_$
as in $\IsoToEqui{\EUnroll e} = \IsoToEqui e$ and treats all other
expressions homomorphically. Formallly, we have this result.
\begin{lemma}
  Suppose that $\typing{\tyIso e}T$ where each recursive type
  occurring in the derivation is contractive.
  Then $\typing{\tyEqui \IsoToEqui{e}}T$.
\end{lemma}
\begin{proof}
  By rule induction on the typing derivation of  $\typing{\tyIso
    e}T$. The only interesting case concerns the $\EUnroll\_$
  expression:
  \begin{mathpar}
    \inferrule{
      \typing{\tyIso e}{\TRec S}
    }{
      \typing{\tyIso \EUnroll e}{S[\TRec[X] S / X]}
    }
  \end{mathpar}
  By induction, we have $\typing{\tyEqui \IsoToEqui{e}}{\TRec S}$.
  From reflexivity of $\eqs$ (Lemma~\ref{lemma:congruence}) and rule
  {\EqUnrollL}, we obtain $\TRec S 
  \eqs S[\TRec[X] S / X]$ and thus  $\TRec S 
  \eqt S[\TRec[X] S / X]$, so that the conversion rule yields
  $\typing{\tyEqui \IsoToEqui{e}}{S[\TRec[X] S / X]}$.

  The translation does not change the structure of the types, so that
  contractiveness is preserved.
\end{proof}

\subsection{Wire compatibility by silencing unroll}
\label{sec:wire-compatibility}

Now that we established a route to go forth and back between
isorecursive and equirecursive session types, we wonder if
isorecursive and equirecursive programs can communicate with one
another. On first sight, the answer is ``no'' because the folklore
semantics of $\EUnroll\_$ involves communication, which renders a
program and its translation according to section~\ref{sec:forward}
or~\ref{sec:backward-translation} incompatible.

However, if we impose the restriction that recursive types are
generally contractive, we can modify the semantics of isorecursive
session types so as not to communicate $\EUnroll\_$ messages. In fact,
$\EUnroll\_$ becomes a no-op which just changes the type. In other
words, we downgrade the process reduction of $\EUnroll\_$ to a simple,
silent expression reduction:
\begin{gather*}
  \reduce{E[\EUnroll a]}{a}
\end{gather*}

At this point, we should have that an equirecursive expression
$\translation e{e'} T$ is wire compatible to its translation
$e'$. However, that statement is not straightforward to state and
prove because the translation introduces explicit conversion
expressions. Intuitively, conversion expressions on session types are
just forwarders of the respective messages, so we arrive at the
following statement for an equational correspondence.

\begin{definition}
  For $\typing{e_1, e_2} T$ define $e_1 = e_2$
  as the reflexive, transitive, symmetric, congruence closure of all
  silent reductions, the equalities of the computational lambda
  calculus, and extensionality.
\end{definition}

\begin{conjecture}
  Suppose that $\translation {e_1}{e_1'} T$.
  If $\reduce[\alpha]{e_1}{e_2}$
  and $\translation{e_2}{e_2''}{T}$,
  then $\reducemany[\alpha]{e_1'}{e_2'}$
  and $e_2' = e_2''$.
\end{conjecture}
If we could establish $\reducemany{e_2''}{e_2'}$ in  the
conclusion, that would result in a reduction correspondence.

The following lemma is a stepping stone for this conjecture. It
establishes that conversions constructed by $\eqt$ behave like
isomorphisms and conversion constructed by $\eqs$ like forwarders.
\begin{conjecture}[Conversions]~\\[-\baselineskip]
  \label{lemma:conversion}
  \begin{enumerate}
    \item If $f : T \eqt T'$, then $f' : T' \eqt T$
      such that $\typing[\CNil]{f}{\TFun T{T'}}$
      and  $\typing[\CNil]{f'}{\TFun {T'}T}$
      and  $f \circ f' = \ELam x x$
      and  $f' \circ f = \ELam x x$.
    \item If $g : S \eqs S'$, then $g' : S' \eqs S$
      such that $\typing[\CNil]{g}{\TFun {\TPair {S} {\TDual{S'}}} \TUnit}$
      and $\typing[\CNil]{g'}{\TFun {\TPair {S'} {\TDual{S}}} \TUnit}$
      and,\\
      for all channels $c : S$,  $c \cong \ELet{c'}{\EFork{( \ELam {\bar c'} g \; (c, \bar c')) }}{\EFork{( \ELam {\bar c} g' \; (c', \bar c)) }} $.
\end{enumerate}
\end{conjecture}
For session type $S$ and $c:S$, $c \cong c'$ means that for all
sequences of session operations $o$ described by $S$, $o\; c = o\; c'$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
