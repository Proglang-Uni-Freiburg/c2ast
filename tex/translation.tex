\section{Translating equi-recursion to iso-recursion and back}

\subsection{Forward translation}
\label{sec:forward}


The set of syntactically valid expressions in the equi-recursive system is a
subset of the syntactically valid expressions in the iso-recursive system. A
simple one-to-one mapping, however, does not preserve well-typedness because
the target type system is explicit about unrolling of the recursive type.

\input{fig-translation}

Instead, the translation judgment $\translation e {e'} T$ in
Figure~\ref{fig:translation} describes the translation of an equi-recursively
typed expression $e$ to an equivalent expression $e'$ in the iso-recursive
system. The only interesting part of the translation process is where the
equi-recursive system makes use of type conversions. Here, an appropriate
conversion function is inserted on the iso-recursive side. These
conversion expressions are specified by the blue parts in figure~\ref{fig:equi-equivalence}.
\begin{mathpar}
  \inferrule{
      \translation e {e'} T \\
      f : T \eqt U
    }{
      \translation e {f \; e'} U
    }
\end{mathpar}

To prove that the translation preserves well-typedness, we
need a few properties of the conversion expression $f$.
\begin{lemma}
  \begin{enumerate}
  \item If $f : T \eqt U$, then $\typing[\CNil]{\tyIso f}{\TFun TU}$.
  \item If $g : R \eqs S$, then $\typing[\CNil]{\tyIso g}{\TFun{\TPair
      R {\TDual S}} \TUnit}$.
  \end{enumerate}
\end{lemma}
% Technically, the expression $g$ generated by the coinductively defined
% judgment $g : R \eqs S$ can be infinitely big. However, the proof of
% such a judgment is a regular tree so that $g$ can be finitely
% represented by a recursive function. The details of turning regular
% coinduction into induction are well-known
% \cite{DBLP:conf/popl/HengleinN11,DBLP:journals/jfp/GapeyevLP02,DBLP:journals/lmcs/Dagnino21}
% and hence omitted.

\begin{lemma}
  \begin{enumerate}
  \item $\typing{\tyEqui e} T$ iff there is some $e'$ such that
    $\translation e {e'} T$.
  \item If $\translation e {e'} T$, then $\typing{\tyIso e'} T$.
  \end{enumerate}
\end{lemma}

\subsection{Backward translation}
\label{sec:backward-translation}

The reverse translation $\IsoToEqui\cdot$ from iso-recursion to equi-recursion is even
simpler. The translation just removes each occurrence of $\EUnroll\_$
as in $\IsoToEqui{\EUnroll e} = \IsoToEqui e$ and treats all other
expressions homomorphically. Formally, we have this result.
\begin{lemma}
  Suppose that $\typing{\tyIso e}T$ where each recursive type
  occurring in the derivation is contractive.
  Then $\typing{\tyEqui \IsoToEqui{e}}T$.
\end{lemma}
\begin{proof}
  By rule induction on the typing derivation of  $\typing{\tyIso
    e}T$. The only interesting case concerns the $\EUnroll\_$
  expression:
  \begin{mathpar}
    \inferrule{
      \typing{\tyIso e}{\TRec S}
    }{
      \typing{\tyIso \EUnroll e}{S[\TRec[X\!] S / X]}
    }
  \end{mathpar}
  By induction, we have $\typing{\tyEqui \IsoToEqui{e}}{\TRec S}$.
  From reflexivity of $\eqs$ (Lemma~\ref{lemma:congruence}) and rule
  {\EqUnrollL}, we obtain $\TRec S 
  \eqs S[\TRec[X\!] S / X]$ and thus  $\TRec S 
  \eqt S[\TRec[X\!] S / X]$, so that the conversion rule yields
  $\typing{\tyEqui \IsoToEqui{e}}{S[\TRec[X\!] S / X]}$.

  The translation does not change the structure of the types, so that
  contractiveness is preserved.
\end{proof}

\subsection{Wire compatibility by silencing unroll}
\label{sec:wire-compatibility}

Now that we established a route to go forth and back between
isorecursive and equirecursive session types, we wonder if
isorecursive and equirecursive programs can communicate with one
another. On first sight, the answer is ``no'' because the folklore
semantics of $\EUnroll\_$ involves communication, which renders a
program and its translation according to section~\ref{sec:forward}
or~\ref{sec:backward-translation} incompatible.

However, if we impose the restriction that recursive types are
generally contractive, we can modify the semantics of isorecursive
session types so as not to communicate $\EUnroll\_$ messages. In fact,
$\EUnroll\_$ becomes a no-op which just changes the type. In other
words, we downgrade the process reduction of $\EUnroll\_$ to a simple,
silent expression reduction:
\begin{gather*}
  \reduce{\EUnroll a}{a}
\end{gather*}

At this point, we should have that an equirecursive expression
$\translation e{e'} T$ is wire compatible to its translation
$e'$. However, this statement is not straightforward to state and
prove because the translation introduces explicit conversion
expressions. As conversion expressions on session types are
just forwarders of the respective messages, we realize that we need to
lift our point of view to the process level.

The translation from equirecursion to isorecursion extends easily to
the process level written as $\Ptranslation p{p'}$ by applying the
expression translation to each process.

% \begin{definition}
%   For processes $p_1$ and $p_2$ such that  $\Ptyping{p_1}$ and
%   $\Ptyping{ p_2}$ define $p_1 = p_2$ 
%   as the reflexive, transitive, symmetric, congruence closure of all
%   silent reductions, and extensionality.
% \end{definition}

\begin{definition}[Simulation and bisimulation]
  For processes $p$ and $q$
  \begin{itemize}
  \item define $p \leftsim q$ if, for all $\alpha$ and $p$ such that
    $\reducemany[\alpha] p{p'}$, then there exists some process $q'$
    such that $\reducemany[\alpha] q{q'}$ and $p' \leftsim q'$;
  \item define $p \bisim q$ if $p \leftsim q$ and $q \leftsim p$.
  \end{itemize}
\end{definition}
\begin{conjecture}
  Suppose that $\Ptranslation {p_1}{p_1'}$.
  If $\reduce[\alpha]{p_1}{p_2}$
  and $\Ptranslation{p_2}{p_2''}$,
  then $\reducemany[\alpha]{p_1'}{p_2'}$
  and $p_2' \bisim p_2''$.
\end{conjecture}


\begin{conjecture}[obsolete]
  Suppose that $\translation {e_1}{e_1'} T$.
  If $\reduce[\alpha]{e_1}{e_2}$
  and $\translation{e_2}{e_2''}{T}$,
  then $\reducemany[\alpha]{e_1'}{e_2'}$
  and $e_2' = e_2''$.
\end{conjecture}
If we could establish $\reducemany{e_2''}{e_2'}$ in  the
conclusion, that would result in a reduction correspondence.

The following lemma is a stepping stone for this conjecture. It
establishes that conversions constructed by $\eqt$ behave like
isomorphisms and conversion constructed by $\eqs$ like forwarders.
\begin{conjecture}[Conversions]~\\[-\baselineskip]
  \label{lemma:conversion}
  \begin{enumerate}
  \item If $f : T \eqt T'$,
    then $f' : T' \eqt T$
    and $\typing[\CNil]{f}{\TFun T{T'}}$
    and  $\typing[\CNil]{f'}{\TFun {T'}T}$
    and  $f \circ f' = \ELam x x$
    and  $f' \circ f = \ELam x x$.
  \item If $g : S \eqs S'$,
    then $g' : S' \eqs S$
    and $\typing[\CNil]{g}{\TFun {\TPair {S} {\TDual{S'}}} \TUnit}$
    and $\typing[\CNil]{g'}{\TFun {\TPair {S'} {\TDual{S}}} \TUnit}$
    and,\\
    for all channels $c : S$,  $c \cong \ELet{c'}{\EFork{( \ELam {\bar c'} g \; (c, \bar c')) }}{\EFork{( \ELam {\bar c} g' \; (c', \bar c)) }} $.
  \end{enumerate}
\end{conjecture}
For session type $S$ and $c:S$, $c \cong c'$ means that for all
sequences of session operations $o$ described by $S$, $o\; c = o\; c'$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
