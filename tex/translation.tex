\section{Translating equi-recursion to iso-recursion and back}

\subsection{Forward translation}
\label{sec:forward}


\input{fig-translation}

The translation judgment $\translation e {e'} T$ in
Figure~\ref{fig:translation} describes the translation of an equi-recursively
typed expression $e$ to an expression $e'$ with the same type in the iso-recursive
system. The translation is mostly just copying. The only interesting part is where the
equi-recursive system makes use of type conversions. At this point, an appropriate
conversion function is inserted on the iso-recursive side. These
conversion expressions are specified by the blue parts in figure~\ref{fig:equi-equivalence}.
\begin{mathpar}
  \inferrule{
      \translation e {e'} T \\
      \convexpr{f} : T \eqt U
    }{
      \translation e {f \; e'} U
    }
\end{mathpar}

To prove that the translation preserves well-typedness, we
need a few properties of the conversion expression $f$.
\begin{lemma}
  \begin{enumerate}
  \item If $f : T \eqt U$, then $\exists f'$ such that  $f' : U \eqt
    T$ and $\typing[\CNil]{\tyIso f}{\TFun TU}$ and $\typing[\CNil]{\tyIso f'}{\TFun UT}$.
  \item If $g : R \eqs S$, then $\exists g'$ such that  $g' : S \eqs
    R$ and $\typing[\CNil]{\tyIso g}{\TFun{\TPair
      R {\TDual S}} \TUnit}$ and $\typing[\CNil]{\tyIso g'}{\TFun{\TPair
      S {\TDual R}} \TUnit}$.
  \end{enumerate}
\end{lemma}
% Technically, the expression $g$ generated by the coinductively defined
% judgment $g : R \eqs S$ can be infinitely big. However, the proof of
% such a judgment is a regular tree so that $g$ can be finitely
% represented by a recursive function. The details of turning regular
% coinduction into induction are well-known
% \cite{DBLP:conf/popl/HengleinN11,DBLP:journals/jfp/GapeyevLP02,DBLP:journals/lmcs/Dagnino21}
% and hence omitted.

\begin{lemma}
  \begin{enumerate}
  \item $\typing{\tyEqui e} T$ iff there is some $e'$ such that
    $\translation e {e'} T$.
  \item If $\translation e {e'} T$, then $\typing{\tyIso e'} T$.
  \end{enumerate}
\end{lemma}

\subsection{Backward translation}
\label{sec:backward-translation}

The reverse translation $\IsoToEqui\cdot$ from iso-recursion to equi-recursion is even
simpler. The translation just removes each occurrence of $\EUnroll\_$
as in $\IsoToEqui{\EUnroll e} = \IsoToEqui e$ and treats all other
expressions homomorphically. Formally, we have this result.
\begin{lemma}
  Suppose that $\typing{\tyIso e}T$ where each recursive type
  occurring in the derivation is contractive.
  Then $\typing{\tyEqui \IsoToEqui{e}}T$.
\end{lemma}
\begin{proof}
  By rule induction on the typing derivation of  $\typing{\tyIso
    e}T$. The only interesting case concerns the $\EUnroll\_$
  expression:
  \begin{mathpar}
    \inferrule{
      \typing{\tyIso e}{\TRec S}
    }{
      \typing{\tyIso \EUnroll e}{S[\TRec[X\!] S / X]}
    }
  \end{mathpar}
  By induction, we have $\typing{\tyEqui \IsoToEqui{e}}{\TRec S}$.
  From reflexivity of $\eqs$ (Lemma~\ref{lemma:congruence}) and rule
  {\EqUnrollL}, we obtain $\TRec S 
  \eqs S[\TRec[X\!] S / X]$ and thus  $\TRec S 
  \eqt S[\TRec[X\!] S / X]$, so that the conversion rule yields
  $\typing{\tyEqui \IsoToEqui{e}}{S[\TRec[X\!] S / X]}$.

  The translation does not change the structure of the types, so that
  contractiveness is preserved.
\end{proof}

\subsection{Wire compatibility by silencing unroll}
\label{sec:wire-compatibility}

Now that we established a route to go forth and back between
isorecursive and equirecursive session types, we wonder if
isorecursive and equirecursive programs can communicate with one
another. On first sight, the answer is ``no'' because the folklore
semantics of $\EUnroll\_$ involves communication, which renders a
program and its translation according to section~\ref{sec:forward}
or~\ref{sec:backward-translation} incompatible.

However, if we impose the restriction that recursive types are
generally contractive, we can modify the semantics of isorecursive
session types so as not to communicate $\EUnroll\_$ messages. In fact,
$\EUnroll\_$ becomes a no-op which just changes the type. In other
words, we downgrade the process reduction of $\EUnroll\_$ to a simple,
silent expression reduction:
\begin{gather*}
  \reduce{\EUnroll a}{a}
\end{gather*}

At this point, we should have that an equirecursive expression
$\translation e{e'} T$ is wire compatible to its translation
$e'$. However, this statement is not straightforward to state and
prove because the translation introduces explicit conversion
expressions. As conversion expressions on session types are
just forwarders of the respective messages, we realize that we need to
lift our point of view to the process level.

The translation from equirecursion to isorecursion extends easily to
the process level written as $\Ptranslation p{p'}$ by applying the
expression translation to each subprocess.

% \begin{definition}
%   For processes $p_1$ and $p_2$ such that  $\Ptyping{p_1}$ and
%   $\Ptyping{ p_2}$ define $p_1 = p_2$ 
%   as the reflexive, transitive, symmetric, congruence closure of all
%   silent reductions, and extensionality.
% \end{definition}

\begin{definition}[Simulation and bisimulation]
  For processes $p$ and $q$ define
  \begin{itemize}
  \item $p \leftsim q$ if, for all $\alpha$ and $p'$ such that
    $\reducemany[\alpha] p{p'}$, then there exists some process $q'$
    such that $\reducemany[\alpha] q{q'}$ and $p' \leftsim q'$;
  \item $p \bisim q$ if $p \leftsim q$ and $q \leftsim p$.
  \end{itemize}
\end{definition}

The first conjecture is needed to prove the second one. It essentially
says that the isomorphisms generated from the equivalence judgments
for types and session types deserve their name.

\begin{conjecture}[Conversion]~
  \begin{enumerate}
  \item
    If $f : T \eqt T'$ and $f' : T' \eqt T$ and $\typing eT$ and
    $\typing {E[e]}\TUnit$, then 
    $\PExp{E[e]} \bisim \PExp{E[f' (f\;e)]}$.
  \item If $g : S \eqs S'$
    and $g' : S' \eqs S$
    and $\Ptyping[\Ctxt, c : S]p$, then\\
    $p \bisim
    \PScope[c', \bar c']\PScope[c_1, \bar c]
    \PPar{\PPar {\PExp{g \; (c, \bar c')}}{\PExp{g' \; (c', \bar c)}}}{p[c_1/c]}$.
  \end{enumerate}
\end{conjecture}

\begin{conjecture}
  Suppose that $\translation {e}{f}T$.
  If $\reduce[\alpha]{e}{e'}$
  and $\translation{e'}{f'}T$,
  then $\exists f''$,  $\reducemany[\alpha]{f}{f''}$
  and $ \reducemany{f'}{f''}$.
\end{conjecture}
\begin{proof}
  Case $\RuleActAppLetL$.
  The translation does not change a non-value into a value, so that
  $\EApp{n'}{e'}$ reduces with the same rule.

  Case $\RuleActAppLetR$. If the translation maps $v$ to a value $v'$,
  then $\EApp{v'}{n'}$ reduces with the same rule.
  However, in general $\translation{v}{\EApp f{e'}}{T}$ if
  $\translation{v}{e'}T$ (where $f$ is a value), so we are looking at reducing $\EApp{\EApp
    f{e'}}{n'}$, a non-value, so that \textsc{\ActAppLetL} applies:
  \begin{gather*}
    \EApp{\EApp f{e'}}{n'}
    \to \ELet y{\EApp f{e'}}{\EApp y{n'}}
    \to^* \ELet y{[f{e'}]}{\EApp y{n'}}
    \to \ELet y{[f{e'}]}{\ELet {y'}{n'}\EApp y{y'}}
  \end{gather*}
  The reduced term translates to $\ELet x {n'} \EApp {\EApp f{e'}} x$
  which reduces as follows:
  \begin{gather*}
    \ELet x {n'} \EApp {\EApp f{e'}} x
    \to^* \ELet x {[n']} \EApp {\EApp f{e'}} x
    \to \ELet x {[n']} \ELet{x'}{\EApp f{e'}}\EApp {x'}x 
  \end{gather*}
\end{proof}

\begin{conjecture}
  Suppose that $\Ptranslation {p}{q}$.
  If $\reduce[\alpha]{p}{p'}$
  and $\Ptranslation{p'}{q'}$,
  then $\exists q''$,  $\reducemany[\alpha]{q}{q''}$
  and $ \reducemany{q'}{ q''}$.
\end{conjecture}


\subsection{Obsolete Stuff}
\label{sec:obsolete-stuff}



\begin{conjecture}[obsolete]
  Suppose that $\translation {e_1}{e_1'} T$.
  If $\reduce[\alpha]{e_1}{e_2}$
  and $\translation{e_2}{e_2''}{T}$,
  then $\reducemany[\alpha]{e_1'}{e_2'}$
  and $e_2' = e_2''$.
\end{conjecture}
If we could establish $\reducemany{e_2''}{e_2'}$ in  the
conclusion, that would result in a reduction correspondence.

The following lemma is a stepping stone for this conjecture. It
establishes that conversions constructed by $\eqt$ behave like
isomorphisms and conversion constructed by $\eqs$ like forwarders.
\begin{conjecture}[Conversions, obsolete]~\\[-\baselineskip]
  \label{lemma:conversion}
  \begin{enumerate}
  \item If $f : T \eqt T'$,
    then $f' : T' \eqt T$
    and $\typing[\CNil]{f}{\TFun T{T'}}$
    and  $\typing[\CNil]{f'}{\TFun {T'}T}$
    and  $f \circ f' = \ELam x x$
    and  $f' \circ f = \ELam x x$.
  \item If $g : S \eqs S'$,
    then $g' : S' \eqs S$
    and $\typing[\CNil]{g}{\TFun {\TPair {S} {\TDual{S'}}} \TUnit}$
    and $\typing[\CNil]{g'}{\TFun {\TPair {S'} {\TDual{S}}} \TUnit}$
    and,\\
    for all channels $c : S$,  $c \cong \ELet{c'}{\EFork{( \ELam {\bar c'} g \; (c, \bar c')) }}{\EFork{( \ELam {\bar c} g' \; (c', \bar c)) }} $.
  \end{enumerate}
\end{conjecture}
For session type $S$ and $c:S$, $c \cong c'$ means that for all
sequences of session operations $o$ described by $S$, $o\; c = o\; c'$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
