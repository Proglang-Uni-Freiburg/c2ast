\section{Translating equi-recursion to iso-recursion and back}

\subsection{Forward translation}
\label{sec:forward}


The set of syntactically valid expressions in the equi-recursive system is a
subset of the syntactically valid expressions in the iso-recursive system. A
simple one-to-one mapping, however, does not preserve well-typedness because
the target type system is explicit about unrolling of the recursive type.

\input{fig-translation}

Instead, the translation judgment $\translation e {e'} T$ in
Figure~\ref{fig:translation} describes the translation of an equi-recursively
typed expression $e$ to an equivalent expression $e'$ in the iso-recursive
system. The only interesting part of the translation process is where the
equi-recursive system makes use of type conversions. Here, an appriopriate
conversion function is inserted on the iso-recursive side. These
conversion expressions are specified by the blue parts in figure~\ref{fig:equi-equivalence}.
\begin{mathpar}
  \inferrule{
      \translation e {e'} T \\
      f : T \eqt U
    }{
      \translation e {f \; e'} U
    }
\end{mathpar}

To prove that the translation preserves well-typedness, we
need a few properties of the conversion expression $f$.
\begin{lemma}
  \begin{enumerate}
  \item If $f : T \eqt U$, then $\typing[\CNil]{\tyIso f}{\TFun TU}$.
  \item If $g : R \eqs S$, then $\typing[\CNil]{\tyIso g}{\TFun{\TPair
      R {\TDual S}} \TUnit}$.
  \end{enumerate}
\end{lemma}
Technically, the expression $g$ generated by the coinductively defined
judgment $g : R \eqs S$ can be infinitely big. However, the proof of
such a judgment is a regular tree so that $g$ can be finitely
represented by a recursive function. The details of turning regular
coinduction into induction are well-known
\cite{DBLP:conf/popl/HengleinN11,DBLP:journals/jfp/GapeyevLP02,DBLP:journals/lmcs/Dagnino21}
and hence omitted.

\begin{lemma}
  \begin{enumerate}
  \item $\typing{\tyEqui e} T$ iff there is some $e'$ such that
    $\translation e {e'} T$.
  \item If $\translation e {e'} T$, then $\typing{\tyIso e'} T$.
  \end{enumerate}
\end{lemma}

\subsection{Backward translation}
\label{sec:backward-translation}

The reverse translation $\IsoToEqui\cdot$ from iso-recursion to equi-recursion is even
simpler. The translation just removes each occurrence of $\EUnroll\_$
as in $\IsoToEqui{\EUnroll e} = \IsoToEqui e$ and treats all other
expressions homomorphically. Formallly, we have this result.
\begin{lemma}
  Suppose that $\typing{\tyIso e}T$ where each recursive type
  occurring in the derivation is contractive.
  Then $\typing{\tyEqui \IsoToEqui{e}}T$.
\end{lemma}
\begin{proof}
  By rule induction on the typing derivation of  $\typing{\tyIso
    e}T$. The only interesting case concerns the $\EUnroll\_$
  expression:
  \begin{mathpar}
    \inferrule{
      \typing{\tyIso e}{\TRec S}
    }{
      \typing{\tyIso \EUnroll e}{S[\TRec[X] S / X]}
    }
  \end{mathpar}
  By induction, we have $\typing{\tyEqui \IsoToEqui{e}}{\TRec S}$.
  From reflexivity of $\eqs$ (Lemma~\ref{lemma:congruence}) and rule
  {\EqUnrollL}, we obtain $\TRec S 
  \eqs S[\TRec[X] S / X]$ and thus  $\TRec S 
  \eqt S[\TRec[X] S / X]$, so that the conversion rule yields
  $\typing{\tyEqui \IsoToEqui{e}}{S[\TRec[X] S / X]}$.

  The translation does not change the structure of the types, so that
  contractiveness is preserved.
\end{proof}

\subsection{Wire compatibility by silencing unroll}
\label{sec:wire-compatibility}

Now that we established a route to go forth and back between
isorecursive and equirecursive session types, we wonder if
isorecursive and equirecursive programs can communicate with one
another. On first sight, the answer is ``no'' because the folklore
semantics of $\EUnroll\_$ involves communication, which renders a
program and its translation according to section~\ref{sec:forward}
or~\ref{sec:backward-translation} incompatible.

However, if we impose the restriction that recursive types are
generally contractive, we can modify the semantics of isorecursive
session types so as not to communicate $\EUnroll\_$ messages. In fact,
$\EUnroll\_$ becomes a no-op which just changes the type. In other
words, we downgrade the process reduction of $\EUnroll\_$ to a simple,
silent expression reduction:
\begin{gather*}
  \reduce{E[\EUnroll a]}{a}
\end{gather*}

At this point, we should have that an equirecursive expression
$\translation e{e'} T$ is wire compatible to its translation
$e'$. However, that statement is not straightforward to state and
prove because the translation introduces explicit conversion
expressions. Intuitively, conversion expressions on session types are
just forwarders of the respective messages, so we arrive at the
following statement for an equational correspondence.

\begin{lemma}
  Suppose that $\translation {e_1}{e_1'} T$.
  If $\reduce[\alpha]{e_1}{e_2}$
  and $\translation{e_2}{e_2''}{T}$,
  then $\reducemany[\alpha]{e_1'}{e_2'}$
  and $e_2' = e_2''$.
\end{lemma}
We may be able to establish $\reducemany{e_2''}{e_2'}$ in  the
conclusion, as that would result in a reduction correspondence.

With $=$ we mean the reflexive, transitive, and symmetric closure of
all silent reductions. The latter include fork reductions as well as
local communication on restricted channels (which are not bound in
$\Ctxt$).
\begin{proof}
  TBC
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
